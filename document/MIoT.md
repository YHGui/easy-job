## 算法

1. 寻找最大的K个数
   - 思路1：先排序，然后取出前K个，事件复杂度威O(N*logN)+O(K)
   - 思路2：利用快排思想，随机找一个元素x，将数组分为两部分，小于x，等于x，大于x，如果大于x的个数大于等于K，则继续在这部分中寻找最大K个数，如果小于K，则在另外部分找剩余的数字，平均事件复杂度为O(N*logK)
   - 思路3：建立小顶堆，容量为K，使用优先级队列来实现，堆顶元素为最大的K个数中最小的一个，时间复杂度为O(N*logK)
2. 海量用户的积分排序问题算法分析
   - 我们可以把[0, 1,000,000)作为一级区间；再把一级区间分为两个2级区间[0, 500,000), [500,000, 1,000,000)，然后把二级区间二分为4个3级区间[0, 250,000), [250,000, 500,000), [500,000, 750,000), [750,000, 1,000,000)，依此类推，最终我们会得到1,000,000个21级区间[0,1), [1,2) … [999,999, 1,000,000)。这实际上是把区间组织成了一种平衡二叉树结构，根结点代表一级区间，每个非叶子结点有两个子结点，左子结点代表低分区间，右子结点代表高分区间。树形分区结构需要在更新时保持一种不变量，非叶子结点的count值总是等于其左右子结点的count值之和。以后，每次用户积分有变化所需要更新的区间数量和积分变化量有关系，积分变化越小更新的区间层次越低。总体上，每次所需要更新的区间数量是用户积分变量的log(n)级别的，也就是说如果用户积分一次变化在百万级，更新区间的数量在二十这个级别。在这种树形分区积分表的辅助下查询积分为s的用户排名，实际上是一个在区间树上由上至下、由粗到细一步步明确s所在位置的过程。比如，对于积分499,000，我们用一个初值为0的排名变量来做累加；首先，它属于1级区间的左子树[0, 500,000)，那么该用户排名应该在右子树[500,000, 1,000,000)的用户数count之后，我们把该count值累加到该用户排名变量，进入下一级区间；其次，它属于3级区间的[250,000, 500,000)，这是2级区间的右子树，所以不用累加count到排名变量，直接进入下一级区间；再次，它属于4级区间的…；直到最后我们把用户积分精确定位在21级区间[499,000, 499,001)，整个累加过程完成，得出排名！
3. 求1-N中数字1的个数
   - N为一位数，则为1，
   - N为两位数，个位出现1的次数不仅和个位数字有关，还和十位有关，N个位大于等于1，那么个位出现1的次数为十位数字加1，即加上数字1的情况，个位为0，则在前一种情况下减去十位最大的时候的情况，如20则不包括21的情况。十位出现1的次数不仅和十位有关，还和个位数有关，十位数字等于1，则十位数上出现1的次数为个位数的数字加1，即加上10的这种情况，十位数大于1时，十位出现1的次数为10，即为10-19的情况。
   - 百位也是如此的思路，最后总结出计算公式
4. 实现O(1)获取最大最小值栈
   - 用一个辅助栈记住每次入栈当前的最大/小值，入栈的时候进行比较，比辅助栈栈顶更大/小则压入栈顶，出栈的时候
5. Path Sum
   - 使用递归的思想分别求左右子树是否有路径和为sum-root.val
6. 寻找第k个丑数
   - 将2，3，5放入优先级队列中，每次弹出最小的那个乘以2，3，5并放入优先级队列中，然后取出最小的如法炮制，同时使用hashset来去重。
7. 升降数组的峰值
   - 通过二分法找到包含答案的一半，如果前一个值大于当前值，处于下降阶段，那么峰值在前半部分，如果当前值小于后一个值，处于上升阶段，峰值在后半部分。
8. 股票买卖
   - ​



