### 正则表达式是什么？

- 正则表达式就是记录文本规则的代码。在编写处理字符串的的程序或网页时，经常会有查找符合某些复杂规则的字符串的需要，正则表达式就是用于描述这些规则的工具。

### 特殊字符

- \b，代表单词的开头或结尾，也就是单词的分界处。虽然通常英文的单词由空格，标点符号或者换行来分隔，但\b并不匹配这些单词分隔字符中的任何一个，它只匹配一个位置。例如精确查找hi这个单词，使用\bhi\b。
- .元字符，匹配除了换行符(\n)以为的任意字符
- *元字符，不代表字符也不代表位置，表示数量，指定它前面的内容可以连续重复任意次数以使整个表达式得到匹配。因此点和\*一起就意味着任意数量的不包含换行的字符
- +元字符，和*类似，\*匹配重复任意次，可能是0，+则匹配重复一次或者更多次。
- \d元字符，匹配一位数字，注意-不是元字符，只能匹配本身连字符。0\d\d-\d\d\d\d\d\d\d\d匹配的就是中国区号为3位的电话号码，也可以如此写0\d{2}-\d{8}，其中{2}{8}分别表示必须连续重复匹配2次(8次)，还可以{2, 8}使用，表示闭区间。
- \w匹配字母或数字或下划线或汉字，\ba\w*\b，先是单词开始，然后是字母a，然后是任意数量的字母或数字，最后单词结束。
- ^元字符，匹配字符串的开始，
- $元字符，匹配字符串的结束，和^一起使用，例如^\d{5, 12}$整个输入必须是5到12个数字。

### 字符转义

- 如果想查找元字符本身的话，如 .，必须使用斜线.。如deerchao\.net

### 重复

- ？表示重复零次或一次
- {n}重复n次
- {n,}重复n次或更多次
- {n,m}重复n到m次

### 字符类

- 如果想匹配的没有预定义的字符集合，比如元音字母，只需要在方括号中列出即可，例如[aeiou]可以匹配任何一个英文元音字母，[.?!]匹配标点符号
- [0-9]与\d含义一直，[a-z0-9A-Z]等同于只考虑的英文情况下的\w
- \(?0\d{2}[) -]?\d{8}匹配几种格式的电话号码，像(010)88886666，022-22334455，02912345678

### 分枝条件

- 指有几种负责，如果满足其中任意一种规则都应该当成匹配，具体方法用|把不同的规则分隔开。0\d{2}-\d{8}|0\d{3}-\d{7}  \(0\d{2}\)[- ]?\d{8}|0\d{2}[- ]?\d{8}
- 分枝条件需要注意各个条件的顺序

### 分组

- 想要重复多个字符需要用小括号来指定子表达式，也称为分组，然后指定这个子表达式的重复次数，例如(\d{1,3}\.){3}\d{1,3}
- 上述看似可以匹配一个ip地址，但是由于ip地址数字不大于255，因此需要限定，更加复杂，例如((2[0-4]\d|25[0-5]|[01]?\d\d?)\.){3}(2[0-4]\d|25[0-5]|[01]?\d\d?)

### 反义

- \W匹配任意不是字母，数字，下划线，汉字的字符
- \S匹配任意不是空白符的字符
- \D匹配任意非数字的字符
- \B匹配任意不是单词开头或结束的位置
- [^x]匹配除了x以外的任意字符
- [^aeiou]匹配除了aeiou这几个字母以外的任意字符

### 后向引用

- 使用小括号指定一个子表达式后，匹配这个子表达式的文本可以在表达式或其它程序中做进一步处理。默认情况下，每个分组会自动拥有一个组号，规则是从左到右，以分组的左括号为标志，第一个出现的分组的组号为1，第二个位2，依此类推。
- 后向引用用于重复搜索前面某个分组匹配的文本。
- 同时也可以自己子表达式的组名(?<Word>\w+)，即将\w+的组名指定为Word了，要反向引用这个分组捕获的内容，可以使用\k<Word>

### 零宽断言

- 查找在某些内容(但并不包括这些内容)之前或之后的东西
- (?=exp)断言自身出现的位置后面能匹配表达式exp
- (?<=exp)断言自身出现的位置的前面能匹配表达式exp

### 负向零宽断言

- 确保某个字符出现，但并不想去匹配它
- (?!exp)，断言此位置的后面不能匹配表达式exp，例如\d{3}(?!\d)匹配三位数字，而且这三位数字的后面不能是数字
- (?<!exp)，断言此位置的前面不能匹配表达式exp，(?<![a-z])\d{7}匹配前面不是小写字母的七位数字

### 注释

- 小括号的另一种用途是通过语法(?#comment)来包含注释
- 要包含注释的话，最好启用“忽略模式里的空白府”选项，这样在编写表达式时能任意添加恐吓，Tab，换行，而实际使用时这些都将被忽略。

### 贪婪与懒惰

- 当正则表达式中包含能接受重复的限定符时，通常的行为时匹配尽可能多的字符。例如a.*b会匹配最长的以a开始，以b结束的字符串，如果用它来搜索aabab的话，将会匹配整个字符串，称之为贪婪匹配。
- 优势需要懒惰匹配，匹配尽可能少的字符。前面给出的限定符都可以转化为懒惰匹配模式，只要在它后面加上一个问号?，这样.*?就意味着匹配任意数量的重复，但是在能使整个匹配成功的前提下使用最少的重复。例如a.\*?b匹配最短的以a开始，以b结束的字符串。作用于aabab的话，将会匹配aab和ab
- *?表示重复任意次，但尽可能少重复。
- +?重复一次或更多次，但尽可能少重复
- ??重复0次或1次，但尽可能少重复
- {n,m}?重复n到m次，但尽可能少重复
- {n,}?重复n次以上，但尽可能少重复

### 处理选项

- IgnoreCase：忽略大小写
- Mutliline多行模式
- Singleline单行模式
- IgnorePatternWhitespace忽略空白
- ExplicitCapture显示捕获，仅仅捕获已被显示命名的组

### 平衡组/递归匹配

- 出现多层括号嵌套的层次性结构，将最长的嵌套捕获出来
- (?'group')把捕获的内容命名为group，并压入堆栈
- (?'-group')从堆栈上弹出最后压入堆栈的名为group的捕获内容，如果堆栈本来为空，则本分组的匹配失败。
- (?(group)yes|no)如果堆栈上存在以名为group的捕获的内容的话，继续匹配yes部分的表达式，否则继续匹配no部分的
- (?!)零宽负向先行断言，由于没有后缀表达式，试图匹配总是失败

 